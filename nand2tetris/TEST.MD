# 추상화 
어떤 개체의 본질을 포착하여 간결한 방식으로 구별해 내는 정신적 활동.

고수준 프로그래밍 언어는
호스트 운영체제나 표준 라이브러레에서 기능을 반드시 제공해야 함.

컴파일 
구문 분석 코드 생성

소스 코드의 텍스트를 분석하여 parse tree라 불리는 데이터 구조로 묶어냄
called syntax analys

구문 분석 트리를 제귀적으로 처리하여 
intermediate language로 기술된 프로그램을 만듬.

C#나 JAVA처럼 VM 상에서 수행되는 generic 명령
-> 출력 결과 어셈블리 언어 -> 2진 코드로 번역 어셈블러

Chip 아키텍처

논리 게이트 이하는 트렌지스터 :
양자역학과 고체물리학 : 물리학자가 정의한 자연계의 추상화.

# 불 논리

불 게이트 : 간단한 칩
불 함수를 물리적으로 구현한 것

boolean argebra :
10으로 참과 거짓을 다루는 대수학

불 연산 -> +- 산술 연산 

불 함수
: 진리표
: 불 연산
: canonical representation

 표준 형식:
$f(x,y,z)=\bar{x}yz +x\bar{y}x+xy\bar{z} $ 


![](/images/TEST/TEST_132628.png)


NAND만으로 and or not을 전부 표현 가능

![](/images/TEST/TEST_133400.png)

실무에서는 not and or를 nand로 제작 후 추상화.

a and b = ~ ~(a and b) = ~ (A NAND B)
a or b = ~a and ~ b  = ~~~(~a and ~b)
= ~a NAND ~b

not a = Nand(a,a)
a AND b = NAND(NAND(a,b),NAND(a,b))
~ (~ (a and b ))
OR = A OR B = NOT A and NOT B
// 문제 정의랑 다르게 바꿈, 문제는 반드시 인풋이 2개
NAND(Nand(A),NAND(B))
// 문제 정답.
NAND(Nand(A,A),NAND(B,B), Nand(A,A),NAND(B,B))

논리 설계란 게이트를 서로 연결해서 더 복잡한 기능을 하는 조합 게이트를 만드는 것.

![](/images/TEST/TEST_133854.png)

내부 아키텍처 : 구현
인터페이스 : 바깥에 노출된 입출력 핀

HDL :
헤더 입출력 인터페이스 정의
파트 내부 구현

## 기본 논리 게이트 :
NAND로 파생할 수 있다.

Not 컨버터 
And
or
Xor IF a!= b then out 1 else out 0.

Multiflexor
if sel = 0 then out a else b
선택 비트 입력을 이용해 하나 선택

![](/images/TEST/TEST_134558.png)

디멀티플렉서 :
선택 비트에 따라 출력선 중 하나 선택

![](/images/TEST/TEST_134627.png)

## 멀티비트 버전 :
컴퓨터 하드웨어는 일반적으로 bus라 불리는
멀티비트 배열에 대해 연산을 수행한다
예를 들어 32비트 컴퓨터는 2개의 32비트 버스에 대해 AND 연산이 가능하다.

32개의 이진 and 게이트를 나란히 놓고 각각의 비트 쌍마다 and를 적용하는 식으로 구현

이 게이트들을 2 개의 32비트 입력 버스와 1개의 32비트 출력 버스를 인터페이스로 하는 하나의 칩으로 합칠 수 있음.

## 기본 게이트의 다입력 버전

입력 논리 게이트들은 multi-way 게이트들로 일반화 가능.

다입력 Or : n개 입력 중 하나가 1이면 1을 출력

![](/images/TEST/TEST_134928.png)

## 다입력 멀티비트 멀티플렉서

MuxMwayN

N비트 M개의 입력 버스 중 하나를 골라 n비트 출력 버스에 출력한다.
선택 입력은 k개의 제어 비트로
k = log2m이다.

![](/images/TEST/TEST_135001.png)

## 다입력 멀티비트 디멀티플렉서

DMuxMway

N비트 입력을 하나 받아 N개중 한개를 선택해
M개의 출력으로 내보낸다. 1000 0100 처럼

선택 입력은 k개의 제어 비트로
k = log2m이다.


![](/images/TEST/TEST_135720.png)

# 불 연산
---

1장에서 만든 논리 게이트들로
온전히 동작하는 산술 연산 장치(ALU)를 만든다.

ALU는 컴퓨터의 모든 산술 및 논리 연산이 이루어지는 핵심 칩

2진수는 기수를 2로 함

2진 덧셈
오른쪽에서 왼쪽으로 하나씩 더하고
자리올림 비트 carry bit를 다음 순서 비트 쌍 하나에 더해줌

맨 위 오버플로는 무시함

## 부호가 있는 2진수

양수와 음수로 나눔

2의 보수 법이라 부름
기수의 보수 법이라고도 함.

``` 복습
a and b = ~ ~(a and b) = ~ (A NAND B)
a or b = ~a and ~ b  = ~~~(~a and ~b)
= ~a NAND ~b
2의 보수
```
$$
  \bar{x} =
    \begin{cases}
      2^n-1 & \text{if x != 0}\\
      0 & \text{otherwise}\\
    \end{cases}       
$$

예를 들어 5비트 2진수에서 -2 또는 음수(00200)을 나타내는 2의 보수는
32 - 00100 = 11100 이다.
둘을 더하면 100000이다.
-x + x 는 2n이기 때문에 2의 보수법이다.

- 2n개의 부호있는 숫자를 표현 가능하다.
- 최대값은 2^(n-1)-1 최소값은 -2(n-1)
- 모든 양수는 0으로 시작
- 모든 음수는 1로 시작
- x에서 -x를 구하려면 최하위 비트 1을 그대로 두고 나머지는 뒤집는더.
- 하드웨어에서 구현이 쉬운 방법은 모두 뒤집고 1을 더하는 것이다
- 이는 2n-x = (2n-1 -x) +1이다.
- 양수와 음수의 덧셈 방식이 완전히 똑같다.
- 뼬셈 시는 보수를 구해 더한다.

## 가산기 명세

- 반가산기 : 두 비트 더함
- 전가산기 : 세 비트를 더함
  - a와b 더하고 결과와 결과를 더함. 전체 결과의 최상위 최하위를 사용
- 가산기 : 두 개의 n 비트 숫자를 더함
- 증분기 : 주어진 숫자에 1을 더함

![](/images/TEST/TEST_150647.png)
xor과 and다 (그림 잘못됨)
### 반가산기 :
2진수 덧셈의 LSB. 시작단계다.
덧셈 결과의 최상위 비트를 sum이라 하고
최하위 비트를 carry라 하자.
결과는 xor와 and로 표현한다.

- 전가산기 :
똑같이 출력은 2개지만
입력이 캐리 포함이다.

- 가산기 :
메모리와 레지스터 칩은 n비트 패턴으로 된 정수를 저장한다. n은 플랫폼에 따라 16, 32 64 등의 값이다.

이런 숫자를 덧셈하는 칩을 멀티비트 가산기 또는 간단하게 가산기라 부른다.


![](/images/TEST/TEST_150915.png)

- 증분기
![](/images/TEST/TEST_152505.png)

2의 보수 만드는 방법
뒤집고 1을 더하는 데 사용함.

## ALU

여기서 설명하는 ALU는 원리는 일반적이지만
보편적으로 적용되지 않는다.
다른 앞의 칩들은 보편적이다.

![](/images/TEST/TEST_152847.png)

ALU를 설계하는 법
먼저 우리가 만들 기초 연산들의 목록을 만든다.
그 연산을 수행하려면 x,y,out을 어떻게 조작해야 하는지 알아본다.
ALU 논리설계를 가능한 한 단순하고 간단하게 만든다.

단순하고 명쾌한 설계란 곧바로 저렴하면서도 강력한 컴퓨터 시스템을 만들 수 있음을 의미한다.

더 공부할 것

- carry look-ahead technique

##\ 순차 논리

불 논리 칩과 산술 칩들은 모두 조합 칩이다.

조합 칩은 입력 값의 조합에만 의존하는 함수를 계산한다.

조합 칩은 상태를 유지하지 않는다.

상태를 유지하는 메모리 소자는 순차 칩으로 만든다.

메모리 소자 구현은 동기화, 클로킹, 피드백 루프 등을 포함한 복잡한 기술이다.

하지만 flip-flop이라는 매우 저수준의 순차 게이트가 이 복잡한 논리를 모두 수행햔다.

2진 셀
레지스터
메모리뱅크
계수기를 만들어 보자.

이것들이 컴퓨터를 구성하는 모든 칩이다.

## 배경

무언가를 기억하는 행위는 본질적으로 시간과 관련있다.
지금 떠올리는 것은 예전 기억이다.

클록 :
대부분의 컴퓨터에서는 마스터 클록으로 시간 진행을 표현한다.

이 하드웨어는 0~1 고 저를 오가는 발진기로 구현된다.

틱-톡 한 주기 시간을 사이클이라 부름.

플립플롭 :

기본적인 순차 소자.
여러 다른 종류가 있지만, 여기선 DFF라는 
데이터 플릿 플롭 사용

**모든 상태 유지 하드웨어의 기초**


레지스터 :

시간이 지나도 값을 저장하고 로드할수 있는 장치.

기본적인 저장 기능 $out(t)=out(t-1)$
구현


![](/images/TEST/TEST_162759.png)
![](/images/TEST/TEST_163850.png)
언제 기억하지 말지 알 수 없고,
내부 핀은 하나의 팬인 단자만 있어야 한다.

입력의 애매함은 멀티플렉서를 도입해서 해결했다.

in에 새 값을 넣고 로드 비트를 1로 하면저장
계속 유지하게 하려면 로드 비트에 0을 준다.

레지스터가 저장할수 있는 비트의 개수는
폭(width)이라 부른다.
멀티비트 값은 word라 함.

메모리 :
word를 표현할 수 있게 되었으니,
이제 임의 길이의 memory bank를 구성할 수 있다.

레지스터를 여러개 쌓으면 그게 램이다.
왜 RAM이냐
`임의 접근`

접근 순서와 관계 없이
무작위로 word를 읽고 쓸 수 있음.
매모리 내의 어떤 단어든 물리적 저장 위치에 관계없이 똑같은 속도로 직접 접근 가능.

폭 너비
단어 값


1. 먼저 n개의 레지스터 RAM에 있는 각 단어들 접근 시 마다 사용되는 유일한 주소를 할당
2. n개의 레지스터 배열 구성, 어떤 주소 j 선택 가능하도록 게이트 논리 설계
3. 데이터 입력, 주소 입력, 로드 비트라는 세 입력을 받는다. 이때 주소흔 현 사이클에서 어떤 RAM 레지스터를 가리킬지를 나타낸다.
4. 어느 시간 어떤 주소(address)에 어떤 단어를(in) 읽을지, 저장할지 여뷰(load)

![](/images/TEST/TEST_163811.png)

램의 용어
1. 데이터 폭 : 각 단어의 비트 수
2. 크기 : 램 내의 단어 수
최신컴퓨터는 폭이 32~64비트
크기가 수억만 개에 달하는 ram들을 사용
크기가 곧 용량.

```
컴퓨터 하드웨어는 일반적으로 bus라 불리는
멀티비트 배열에 대해 연산을 수행한다
폭은 곧 버스의 크기다.
```

## 계수기

계수기 counter는
매 시간마다 내부 상태 값을 증가시키는 순차 칩으로, out(t) = out(t-1)+c 라는 함수를 연산한다. 보통 c는 1이다.

디지털 아키텍처에서 매우 중요한 역할
PC 카운터가 바로 이것.
일반적으로 cpu에 탑재되어
다음에 실행해야 할 명령어 주소를 출력.

계수기 칩은 표준 레지스터의 입/출력 논리와
상태값에 상수를 더하는 논리가 조합된 것.

일반적으로 계수기에는 상태를 0으로 만들거나, 새로운 계수 값을 불러오거나, 값을 감소, 증가시키는 기능이 있음.

![](/images/TEST/TEST_164600.png)

## 시간 문제

이 장의 칩들은 모두 순차적임
즉 하나 이상의 DFF 칩을 장착 (직간접)
상태를 유지(메모리)하거나 조작(계수기)함
이 기능은 FEEDBACK LOOP사용

https://m.blog.naver.com/PostView.nhn?blogId=leeyunghuk1&logNo=220980312714&proxyReferer=https:%2F%2Fwww.google.com%2F

## 플립 플롭

![](/images/TEST/TEST_165447.png)

![](/images/TEST/TEST_165612.png)

전원이 공급되는 한
현재 상태 그대로 유지하는 논리회로
1비트를 기억하는 메모리 소자.
레지스터 구성회로

기억 원리 > 되먹임
![](/images/TEST/TEST_171515.png)
전선 꺼도 켜져있음

한번 0을 집어넣었더니 계속켜짐
![](/images/TEST/TEST_171601.png)

꺼진 상태에서 1 넣으면 계속 꺼짐
![](/images/TEST/TEST_171644.png)
`q랑 q바 무조건 반대`

입력을 주고싶어서 래치로 만듬
![](/images/TEST/TEST_171816.png)

리셋은 출력을 0으로 만듬
가장 큰 차이는 클럭 입력이 있냐 없느냐

Q가 1이고 Q바가 0

![](/images/TEST/TEST_172004.png)
하나라도 출력이 1이면 0 (NOR)
00이면 출력 변하지 않음
![](/images/TEST/TEST_172120.png)
하나라도 입력이 1이면 출력이 0

![](/images/TEST/TEST_172407.png)

불변은 출력을 01 10으로 검증 (전 상태)
하나라도 입력이 0이면 출력 1 NAND
나머지는 서로 반대이기 때문에 검증 가능

래치 입력이 바뀌면 출력이 바뀜

플립플롭 :
입력이 바뀜과 동시에 클록과 동기화해서 출력이 바뀜

클럭형 RS 플립플롭:
![](/images/TEST/TEST_172959.png)

NOR 래치 앞에 플립플롭

![](/images/TEST/TEST_173605.png)

(앞에 NAND가 아니라 AND임!!!)
앞에 AND에서 클락이 1이면
(클럭은 무조건 1)
좌우에 의해 결정됨
AND 게이트 하나라도 0이면 출력이 0
NOR 00 불변
-> 클럭 0이면 신경 x
클럭에 1이 들어가면 생각봐야함.
AND에서 하나가 1이면 나머지가 0이면 0
1이면 1이 나옴 나머지에 의해 결정됨.
00은 불변 (클럭 00과 동일)
AND 입력 R이 0이고 S가 1이면 Q 1 Q바 0
AND 입력 R이 1이고 S가 0이면 Q 0 Q바 1
11금지

set이 출력을 1로 해줌
![](/images/TEST/TEST_174328.png)

클럭 상승 엣지에서 S와 R을 바라봄

![](/images/TEST/TEST_175049.png)

진리표는 동일
![](/images/TEST/TEST_175211.png)
00은 유지

`여기표`

직전 결과를 이용해 특정 결과값을 만들기 위해
입력을 어떻게 주느냐?

JK 플릿플롭

S=R=1일 떄 동작 안되는거 보완
J set K rest

![](/images/TEST/TEST_175432.png)

![](/images/TEST/TEST_175511.png)

JK 플릿플롭은 RS플릿플롭의 출력을 피드백 시킴
![](/images/TEST/TEST_175546.png)

1. 출력 Q 1 Q바 0

![](/images/TEST/TEST_175713.png)

![](/images/TEST/TEST_175729.png)

![](/images/TEST/TEST_175742.png)

![](/images/TEST/TEST_175814.png)

![](/images/TEST/TEST_175907.png)

![](/images/TEST/TEST_180015.png)
NOR은 하나라도 1이 들어가면 0
NAND는 하나라도 0이 들어가면 1

![](/images/TEST/TEST_180405.png)

![](/images/TEST/TEST_180624.png)

## D플릿플롭
제일 중요
데이터 플릿플롭
D가 0이면 Q는 0
D가 1이면 Q는 1
![](/images/TEST/TEST_180658.png)

# T플릿플롭

![](/images/TEST/TEST_180816.png)

# 마스터 슬레이브 플릿플롭
레이스 현상 방지
출력 층의 일부 신호가 입력 측에 궤환되어 유발됨.

![](/images/TEST/TEST_181234.png)

![](/images/TEST/TEST_182154.png)
하강 엣지에서 동작하게 함.
negative triggerd flip-flop

![](/images/TEST/TEST_182919.png)

t가 1인동안 계속 바뀔 수 있음.
t가 매우 짧아야함
T/2  < propagation delay of flip-flop
edge trigger
**master slave**

# 기계어

컴퓨터는 어떤 하드웨어 플랫폼을 더 저수준 칩으로 어떻게  구성하는지 설명할 수 있다.

기계어의 함수를 어떻게 정의하고 사용하는지 추상적으로도 설명 가능하다.

기계어 프로그램을 먼저 살펴보면 프로그래밍 방법 뿐 아니라 하드웨어 설계 이유 이해에 도움이 된다.

정교한 소프트웨어 시스템의 밑바닥은
실제로는 매우 단순하고 기초적인 하드웨어 연산 명령어들로 구성된다.

```
기계어는 프로세서와 레지스터를 이용해서
메모리를 조작할 수 있도록 미리 정의한 규칙이다
```

메모리, 프로세서, 레지스터

기계어 프로그램은 명령어들을 코드화한 것

이 명령이 뭔지 알려면 하드웨어 플랫폼의 명령 집합을 알아야 함.

2진 코드는 암호같아 보임으로
기계어는 보통 2진 코드와 연상 기호를 둘다 사용하도록 되어있음
mnemonic
1000101010101010
addr3r1r9 r3을 r1+r9로 설정하라

한단계 더 추상화하면 프로그램을 작성도 가능.
-> 어셈블리 언어 어셈블리
어셈블리를 2진 코드로 번역하느 프로그램 : 어셈블러


![](/images/TEST/TEST_073249.png)

비트 반전
비트 이동

메모리 접근 :
load와 store -> 레지스터와 메모리 사이 데이터를 이동시키는 명령
몇가지 봉류의 주소 지정 모드가 있음.

- 직접 주소 지정 방식 : 특정 주소를 직접 씀
  LOAD R1 , 67 R1 <= Memory[67]

- 즉시 주소 지정 방식 : 명령어 코드에 있는 상수를 불러옴
  LOAD R1 , 67 R1 <-67

- 간접 주소 지정 방식 : 메모리 주소 하드코딩 x 필요한 값 있는 메모리 위치 참조/ 포인터를 다루는데 사용
  ADD R1, foo,j = R1<- foo+j (x = *(foo+j) = foo[j])
  LOAD* R2, R1 // R2 <- Memory[R1]
  STR R2, x // x<-R2

Flow of Control : 제어 흐름
프로그램에서는 보통 명령 하나씩 순서대로 실행되지만,
다음번 명령 말고 갑자기 다른 위치로 분기해서 실행되기도 함.
분기에는 반복, 조건 실행, 서브루틴 호출 (다른 코드 세그먼트로 이동)
등 몇 가지 종류가 있음.
-> 선택된 주소로 점프하는 기능 사용

### 핵 기계어 명세

핵 기계어는 폰 노이만 플랫폼
CPU //  명령용과 데이터용으로 분리된 두 개의 메모리 모듈
두 개의 메모리 매핑 I/O 장치 (스크린과 키보드)로 구성된 16비트 장치이다.

#### 메모리 주소 공간
명령어 메모리와 데이터 메모리로 분리되어 있음
폭이 16비트인
두 메모리의 주소 공간은 15비트
최대 32K 16비트 단어들에 주소 할당 가능

명령어 메모리에 존재하는 프로그램만 수행함
읽기 전용임

- 레지스터
  D와 A라 불리는 16비트 레지스터가 있음
  A = D-1이나
  D != A 같은 논리 명령으로 직접 조작 가능
  D는 데이터 저장 용도로만 사용
  A는 데이터 값 혹은 데이터 메모리의 주소나 명령어 메모리의 주소로 해석 가능.
  핵 명령어는 폭이 16 주소는 15비트이므로, 주소와 연산코드를 동시에 못넣음
  M으로만 메모리 접근 가능
  D = M+1
  M은 항상 A 레지스터 현재 값을 주소로 하는 메모리 내 단어 참조
  D = M[516]-1 하려면
  A- 516 
  D = m-1 해야함
  메모리 직접 접근 용도로 사용

cpu :
기본 구성으로는 레지스터[1], 프로그램 카운터[2], 명령어 레지스터[3], 산술논리연산장치(ALU: arithmetic logic unit)[4], 제어부[5]와 내부 버스 등이 있다. 그 외에도 캐시 같은 부가 장치도 들어가 있는 경우가 대다수.
2. 설명